[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode unshaded;

uniform vec4 modulate: hint_color = vec4(1,1,1,1);
uniform sampler2D image_texture : hint_albedo;
uniform vec2 image_size = vec2(64,64);
uniform bool lock_aspect = false;
uniform float aspect_ratio = 1.3333333;
uniform vec2 fov = vec2(180.0, 90.0);
uniform vec2 tiling = vec2(1, 1);
uniform vec2 offset = vec2(0.0, 0.0);
uniform vec2 scrolling_velocity = vec2(0.0);
uniform float alpha_scissor = 0;

varying vec2 BG_COORDS;
varying vec2 BG_SCALE;

const float PI = 3.14159265358979323846;

vec4 fromLinear(vec4 linearRGB)
{
    bvec3 cutoff = lessThan(linearRGB.rgb, vec3(0.0031308));
    vec3 higher = vec3(1.055)*pow(linearRGB.rgb, vec3(1.0/2.4)) - vec3(0.055);
    vec3 lower = linearRGB.rgb * vec3(12.92);

    return vec4(mix(higher, lower, cutoff), linearRGB.a);
}

void vertex() {
	//Camera YX rotation per Basis.get_euler source code
	float y = atan(CAMERA_MATRIX[0][2], CAMERA_MATRIX[2][2]);
	float x = asin(CAMERA_MATRIX[1][2]);
	
	//Map rotation to screen space
	BG_COORDS = vec2(y * 0.5, -x) * -(1.0 / PI);
	BG_COORDS.y += 0.5;
	
	BG_SCALE.y = fov.y * (1.0 / 180.0);
	BG_SCALE.x = !lock_aspect ? 
		fov.x * (1.0 / 360.0) : 
		VIEWPORT_SIZE.x / (VIEWPORT_SIZE.y * aspect_ratio) * BG_SCALE.y;
	
	//Keep background centered vertically when FOV changes
	BG_COORDS.y *= BG_SCALE.y > 1.0 ? 0.0 : 1.0 - BG_SCALE.y;
	COLOR.rgb = fromLinear(COLOR.rgba).rgb;
}

void fragment() {
	vec4 filtered_tex = texture(image_texture, ((SCREEN_UV + vec2(-offset.x, offset.y)) * BG_SCALE + BG_COORDS + scrolling_velocity*TIME) * tiling) * modulate.rgba * COLOR.rgba;
	ALBEDO = filtered_tex.rgb;
    ALPHA_SCISSOR = alpha_scissor;
}"
